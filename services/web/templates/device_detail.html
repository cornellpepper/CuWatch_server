{% extends "base.html" %}
{% block title %}Device {{ device_id }} – CuWatch{% endblock %}
{% block style %}
<style>
.row { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-top: 1rem; }
.card { border: 1px solid #ddd; border-radius: 10px; padding: 1rem; }
.grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
.stat { font-size: 1.2rem; }
.chart-container { width: 100%; max-width: 100%; overflow-x: auto; }
canvas { display: block; max-width: 100%; height: 300px; border: 1px solid #ddd; border-radius: 6px; }
@media (max-width: 800px){ .grid2 { grid-template-columns: 1fr; } }
label,input,select,button { font: inherit; }
input[type="number"] { width: 6rem; }
.controls { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
.small { color: #555; font-size: .9rem; }
table { border-collapse: collapse; width: 100%; }
th, td { padding: .35rem .5rem; border-bottom: 1px solid #eee; font-size: .9rem; }
th { text-align: left; background: #fafafa; position: sticky; top: 0; }
tbody { display: block; max-height: 260px; overflow: auto; }
thead, tbody tr { display: table; width: 100%; table-layout: fixed; }
.statusbox { border: 1px solid #eee; background: #fafafa; border-radius: 6px; padding: .5rem; height: 180px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .85rem; white-space: pre-wrap; }
/* Override for status KV table to be non-scrollable */
#statusKv thead th { position: static; }
#statusKv tbody { display: table-row-group; max-height: none; overflow: visible; }
#statusKv thead, #statusKv tbody tr { display: table-row; width: auto; table-layout: auto; }
/* Controls table layout: two columns, not scrollable or sticky */
#ctrlTbl { width: 100%; border-collapse: collapse; }
#ctrlTbl thead, #ctrlTbl tbody tr { display: table-row; width: auto; table-layout: auto; }
#ctrlTbl tbody { display: table-row-group; max-height: none; overflow: visible; }
#ctrlTbl th, #ctrlTbl td { padding: .35rem .5rem; border-bottom: 1px solid #eee; font-size: .9rem; }
#ctrlTbl th { text-align: right; background: transparent; position: static; width: 220px; white-space: nowrap; }
#ctrlTbl td > * { margin-right: .5rem; }
/* Outlined button wrapper for control actions */
.btn-box { display: inline-block; border: 1px solid #bbb; border-radius: 6px; padding: 4px; background: #fff; }
.btn-box .btn { background: transparent; color: var(--black); border: none; padding: .35rem .8rem; }
.btn-box .btn:hover { background: var(--gray200); }
.btn-box .btn.danger { color: var(--carnelian); }
</style>
{% endblock %}
{% block content %}
<nav style="margin-bottom:1rem;">
  <a href="{{ url_for('device_select') }}" class="btn" style="background:var(--gray200);color:var(--black);">← Devices</a>
  <a href="{{ url_for('download_page', device_id=device_id) }}" class="btn">Download CSVs</a>
  <a href="{{ url_for('device_runs_page', device_id=device_id) }}" class="btn" style="background:var(--gray200);color:var(--black);">Runs</a>
</nav>
<h2>CuWatch Node {{ device_id }}</h2>
<div class="row" style="margin-top: 1rem;">
  <div class="card">
    <h3 class="card-title">Current Status</h3>
    <div class="small mb-2">Last update: <span id="statusUpdated">never</span></div>
    <table id="statusKv" class="table table-sm table-striped align-middle mb-0">
      <thead class="table-light">
        <tr>
          <th style="width: 220px;">Key</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody id="statusKvBody"></tbody>
    </table>
  </div>
</div>
<div class="row">
  <div class="card">
    <div>
      <h3>Live Rate (Hz)</h3>
      <div class="stat"><span id="rate">–</span></div>
      <div class="small">Computed using absolute timestamps (<code>ts</code>) over the selected time window.</div>
      <div class="controls" style="margin-top:.5rem">
        <label>Poll (s)
          <input type="number" id="pollSec" min="1" value="5">
        </label>
        <label>Window
          <select id="windowSel">
            <option value="300">5 min</option>
            <option value="1800" selected>30 min</option>
            <option value="3600">1 hour</option>
            <option value="7200">2 hours</option>
          </select>
        </label>
        <button id="reload" class="btn" style="padding:.3rem .8rem;">Reload</button>
      </div>
      <div class="chart-container">
        <canvas id="plot"></canvas>
      </div>
    </div>
  </div>
</div>
<div class="row" style="margin-top: 1rem;">
  <div class="card">
    <h3>Controls</h3>
    <table id="ctrlTbl">
      <tbody>
        <tr>
          <th>Threshold (0–4095)</th>
          <td>
            <input type="number" id="thresholdInput" min="0" max="4095" step="1" placeholder="e.g. 2048">
            <button id="sendThreshold" class="btn">Send</button>
            <span id="thresholdStatus" class="small"></span>
          </td>
        </tr>
        <tr>
          <th>Shutdown</th>
          <td>
            <span class="btn-box"><button id="sendShutdown" class="btn danger">Shutdown</button></span>
            <span id="shutdownStatus" class="small"></span>
          </td>
        </tr>
        <tr>
          <th>New Run</th>
          <td>
            <span class="btn-box"><button id="sendNewRun" class="btn">New Run</button></span>
            <span id="newRunStatus" class="small"></span>
          </td>
        </tr>
        <tr>
          <th>Make leader</th>
          <td>
            <select id="makeLeaderSel">
              <option value="true">true</option>
              <option value="false" selected>false</option>
            </select>
            <button id="sendMakeLeader" class="btn">Send</button>
            <span id="makeLeaderStatus" class="small"></span>
          </td>
        </tr>
      </tbody>
    </table>
    <div class="small" style="margin-top:.5rem;">All controls send JSON to MQTT topic <code>control/{{ device_id }}/set</code> (non‑retained commands).</div>
  </div>
</div>
<div class="row" style="margin-top: 1rem;">
  <div class="card">
    <h3>Latest Samples</h3>
    <table>
      <thead>
        <tr>
          <th>ts</th>
          <th>muon_count</th>
          <th>adc_v</th>
          <th>temp_adc_v</th>
          <th>dt</th>
          <th>coincidence</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>
{% endblock %}
{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script>
      const deviceId = "{{ device_id }}";

      const elRate = document.getElementById('rate');
      const elPlot = document.getElementById('plot');
      const elBody = document.getElementById('tbody');
      const elPoll = document.getElementById('pollSec');
      const elWindow = document.getElementById('windowSel');
      const elReload = document.getElementById('reload');

      let timer = null;
      let inFlight = false;
      let backoffMs = 0; // grows on errors, reset on success

      // Initialize Chart.js line chart
      const rateChart = new Chart(elPlot.getContext('2d'), {
        type: 'line',
        data: {
          datasets: [{
            label: 'Rate (Hz)',
            data: [],
            borderColor: '#1f77b4',
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
          }]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'yyyy-MM-dd HH:mm:ss', unit: 'minute' },
              title: { display: true, text: 'Time (localtime)' }
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: 'Rate (Hz)' }
            }
          },
          plugins: {
            legend: { display: true },
            tooltip: { mode: 'index', intersect: false }
          }
        }
      });

      function computeRates(rows, windowSec) {
        // rows are typically newest-first from /api; normalize to time-ascending and drop bad rows
        const YEAR2000 = 946684800; // seconds since epoch
        const asc = [];
        for (const r of [...rows]) {
          if (!r || r.muon_count == null || !r.ts) continue;
          const tSec = new Date(r.ts).getTime() / 1000; // seconds
          if (!isFinite(tSec) || tSec < YEAR2000) continue;
          asc.push({ t: tSec, c: Number(r.muon_count) });
        }
        // sort ascending by time; break ties with muon_count
        asc.sort((a,b) => (a.t !== b.t) ? (a.t - b.t) : (a.c - b.c));
        if (asc.length < 2) return [];

        // Exact-width sliding window using left-boundary interpolation.
        // For each point at time ti, compute rate over [ti - windowSec, ti].
        // Skip outputs until we have a full window of history to eliminate the edge spike.
        const rates = [];
        let l = 0; // left pointer (last point with t <= tLeft)
        for (let i = 0; i < asc.length; i++) {
          const ti = asc[i].t;
          const tLeft = ti - windowSec;
          // Advance left pointer to the last point with t <= tLeft
          while (l + 1 < asc.length && asc[l + 1].t <= tLeft) l++;
          if (tLeft < asc[0].t) continue; // not enough history for a full window
          if (l >= i) continue; // need at least one interval before i

          // Interpolate cumulative count at tLeft between asc[l] and asc[l+1] (if available)
          const tL = asc[l].t, cL = asc[l].c;
          let cLeft = cL;
          if (l + 1 <= i) {
            const tR = asc[l + 1].t, cR = asc[l + 1].c;
            if (tR > tL && tLeft > tL) {
              const f = (tLeft - tL) / (tR - tL);
              cLeft = cL + f * (cR - cL);
            }
          }

          let dc = asc[i].c - cLeft;
          if (dc < 0) dc = 0; // guard counter reset
          const r = dc / windowSec;
          if (isFinite(r)) rates.push({ t: ti, r });
        }
        return rates;
      }

      // Replaces drawPlot
      function updateChart(rates) {
        // Set x-axis window to match selected time window
        if (rates.length) {
          const windowSec = Math.max(300, Number(elWindow.value) || 1800);
          const now = Date.now();
          rateChart.options.scales.x.min = now - windowSec * 1000;
          rateChart.options.scales.x.max = now;
        } else {
          rateChart.options.scales.x.min = undefined;
          rateChart.options.scales.x.max = undefined;
        }
        rateChart.data.datasets[0].data = rates.map(p => ({ x: p.t * 1000, y: p.r }));
        rateChart.update();
      }

      function renderTable(rows) {
        const latest = rows.slice(0, 50); // show newest 50
        elBody.innerHTML = latest.map(r => `
          <tr>
            <td>${r.ts ?? ''}</td>
            <td>${r.muon_count ?? ''}</td>
            <td>${r.adc_v ?? ''}</td>
            <td>${r.temp_adc_v ?? ''}</td>
            <td>${r.dt ?? ''}</td>
            <td>${r.coincidence ? 'true' : 'false'}</td>
          </tr>
        `).join('');
      }

      async function loadOnce() {
        if (inFlight) return;
        inFlight = true;
        const windowSec = Math.max(300, Number(elWindow.value) || 1800); // enforce ≥5 min

        // Fetch enough data to fully cover the selected window.
        // Assume ≤2 Hz typical upper bound with margin; cap at API limit (50k).
        const estMaxRate = 2; // events/sec upper bound
        const limit = Math.min(50000, Math.max(1000, Math.ceil(windowSec * estMaxRate * 1.5)));

        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), 10000); // 10s timeout

        try {
          const nowMs = Date.now();
          const startIso = new Date(nowMs - windowSec * 1000).toISOString();
          const res = await fetch(`/api/samples/${encodeURIComponent(deviceId)}?limit=${limit}&start=${encodeURIComponent(startIso)}&_ts=${Date.now()}`, { signal: controller.signal });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json(); // newest-first (by ts)

          // For deterministic ordering when multiple rows share the same timestamp,
          // sort by ts desc, then muon_count desc as a tie-breaker.
          const sorted = [...data].sort((a, b) => {
            const ta = a && a.ts ? new Date(a.ts).getTime() : 0;
            const tb = b && b.ts ? new Date(b.ts).getTime() : 0;
            if (ta !== tb) return tb - ta; // newer first
            const ca = (a && a.muon_count != null) ? Number(a.muon_count) : -Infinity;
            const cb = (b && b.muon_count != null) ? Number(b.muon_count) : -Infinity;
            return cb - ca; // higher count first
          });

          // Keep only samples within the selected window for table display
          const sinceMs = nowMs - windowSec * 1000;
          const inWindow = sorted.filter(r => {
            if (!r.ts) return false;
            const tms = new Date(r.ts).getTime();
            return isFinite(tms) && tms >= sinceMs;
          });
          renderTable(inWindow.length ? inWindow : sorted.slice(0, 50)); // fallback if empty

          const rates = computeRates(sorted, windowSec);
          if (rates.length) { // update the rate display
            elRate.textContent = rates[rates.length - 1].r.toFixed(2);
          } else {
            elRate.textContent = '–';
          }
          updateChart(rates);

          // success -> reset backoff
          backoffMs = 0;
        } catch (e) {
          console.error('loadOnce error', e);
          // nudge UI to show stale
          elRate.textContent = '–';
          // increase backoff up to 30s and schedule a one-off retry
          backoffMs = Math.min(30000, (backoffMs || 2000) * 2);
          setTimeout(() => {
            // only retry if we are not already polling (avoid stampede)
            if (!inFlight) loadOnce().catch(() => {});
          }, backoffMs);
        } finally {
          clearTimeout(t);
          inFlight = false;
        }
      }

      function startPolling() {
        const sec = Math.max(1, Number(elPoll.value) || 2);
        if (timer) clearInterval(timer);
        timer = setInterval(() => {
          // if a previous load is still running, skip this tick
          if (!inFlight) loadOnce().catch(() => {});
        }, sec * 1000);
      }

      elReload.addEventListener('click', () => {
        loadOnce().catch(console.error);
      });

      // Kickoff
      loadOnce().catch(console.error);
      startPolling();
      elPoll.addEventListener('change', startPolling);

      // Refresh immediately when the selected time window changes
      elWindow.addEventListener('change', () => {
        loadOnce().catch(console.error);
      });

      // Pause polling when the tab is hidden to avoid browser throttling; resume when visible
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          if (timer) {
            clearInterval(timer);
            timer = null;
          }
        } else {
          // on return, do an immediate refresh and restart polling
          loadOnce().catch(() => {});
          startPolling();
        }
      });

      // Live status (current values) via WebSocket
      const statusKvBody = document.getElementById('statusKvBody');
      const elStatusUpdated = document.getElementById('statusUpdated');
      let currentStatus = null;

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }

      function renderStatusKV() {
        if (!currentStatus) return;
        const entries = Object.entries(currentStatus).filter(([k,_]) => !String(k).startsWith('_'));
        entries.sort(([a],[b]) => a.localeCompare(b));
        statusKvBody.innerHTML = entries.map(([k,v]) => {
          let val = v;
          if (typeof v === 'object' && v !== null) val = JSON.stringify(v);
          return `<tr><th scope="row">${escapeHtml(k)}</th><td><code>${escapeHtml(val)}</code></td></tr>`;
        }).join('');
      }
      try {
        const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
        const ws = new WebSocket(`${wsProto}://${location.host}/ws`);
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            const topic = msg.topic || '';
            if (topic === `status/${deviceId}`) {
              const payload = msg.payload;
              currentStatus = (payload && typeof payload === 'object') ? payload : { message: String(payload) };
              if (elStatusUpdated) elStatusUpdated.textContent = new Date().toISOString();
              renderStatusKV();
            }
          } catch {}
        };
      } catch {}

      // Periodic refresh (every 30 seconds) to re-render latest values
      setInterval(renderStatusKV, 30000);

      // Threshold control
      const elThr = document.getElementById('thresholdInput');
      const elThrBtn = document.getElementById('sendThreshold');
      const elThrStatus = document.getElementById('thresholdStatus');
      const elShutdownBtn = document.getElementById('sendShutdown');
      const elShutdownStatus = document.getElementById('shutdownStatus');
      const elNewRunBtn = document.getElementById('sendNewRun');
      const elNewRunStatus = document.getElementById('newRunStatus');
      const elMakeLeaderSel = document.getElementById('makeLeaderSel');
      const elMakeLeaderBtn = document.getElementById('sendMakeLeader');
      const elMakeLeaderStatus = document.getElementById('makeLeaderStatus');

      async function sendThreshold() {
        elThrStatus.textContent = '';
        const raw = elThr.value.trim();
        if (!raw) {
          elThrStatus.textContent = 'Enter a value';
          return;
        }
        const n = Number(raw);
        if (!Number.isInteger(n) || n < 0 || n > 4095) {
          elThrStatus.textContent = 'Must be integer 0–4095';
          return;
        }
        try {
          const res = await fetch(`/api/control/${encodeURIComponent(deviceId)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ threshold: n })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || data.ok === false) {
            elThrStatus.textContent = data.error || 'Failed to send';
          } else {
            elThrStatus.textContent = 'Sent';
          }
        } catch (e) {
          elThrStatus.textContent = 'Network error';
        }
      }

      elThrBtn.addEventListener('click', sendThreshold);

      function withCmdId(obj) {
        try {
          return Object.assign({_cmd_id: Date.now()}, obj);
        } catch {
          return {_cmd_id: Date.now()};
        }
      }
      async function sendJsonPayload(payload, statusEl) {
        try {
          statusEl.textContent = '';
          const res = await fetch(`/api/control/${encodeURIComponent(deviceId)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || data.ok === false) {
            statusEl.textContent = (data && data.error) ? data.error : 'Failed to send';
          } else {
            statusEl.textContent = 'Sent';
          }
        } catch (e) {
          statusEl.textContent = 'Network error';
        }
      }

      elShutdownBtn.addEventListener('click', () => {
        // Send an object and include a transient command id for de-duplication
        sendJsonPayload(withCmdId({ shutdown: true }), elShutdownStatus);
      });

      elNewRunBtn.addEventListener('click', () => {
        // Send an object and include a transient command id for de-duplication
        sendJsonPayload(withCmdId({ new_run: true }), elNewRunStatus);
      });

      elMakeLeaderBtn.addEventListener('click', () => {
        const val = String(elMakeLeaderSel.value).toLowerCase() === 'true';
        // Send an object and include a transient command id for de-duplication
        sendJsonPayload(withCmdId({ make_leader: val }), elMakeLeaderStatus);
      });
    </script>
{% endblock %}
