{% extends "base.html" %}
{% block title %}Device {{ device_id }} – CuWatch{% endblock %}
{% block style %}
<style>
.row { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-top: 1rem; }
.card { border: 1px solid #ddd; border-radius: 10px; padding: 1rem; }
.grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
.stat { font-size: 1.2rem; }
.chart-container { width: 100%; max-width: 100%; overflow-x: auto; }
canvas { display: block; max-width: 100%; height: 300px; border: 1px solid #ddd; border-radius: 6px; }
@media (max-width: 800px){ .grid2 { grid-template-columns: 1fr; } }
label,input,select,button { font: inherit; }
input[type="number"] { width: 6rem; }
.controls { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
.small { color: #555; font-size: .9rem; }
table { border-collapse: collapse; width: 100%; }
th, td { padding: .35rem .5rem; border-bottom: 1px solid #eee; font-size: .9rem; }
th { text-align: left; background: #fafafa; position: sticky; top: 0; }
tbody { display: block; max-height: 260px; overflow: auto; }
thead, tbody tr { display: table; width: 100%; table-layout: fixed; }
.statusbox { border: 1px solid #eee; background: #fafafa; border-radius: 6px; padding: .5rem; height: 180px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .85rem; white-space: pre-wrap; }
/* Override for status KV table to be non-scrollable */
#statusKv thead th { position: static; }
#statusKv tbody { display: table-row-group; max-height: none; overflow: visible; }
#statusKv thead, #statusKv tbody tr { display: table-row; width: auto; table-layout: auto; }
</style>
{% endblock %}
{% block content %}
<nav style="margin-bottom:1rem;">
  <a href="{{ url_for('device_select') }}" class="btn" style="background:var(--gray200);color:var(--black);">← Devices</a>
  <a href="{{ url_for('download_page', device_id=device_id) }}" class="btn">Download CSVs</a>
</nav>
<h2>CuWatch Node {{ device_id }}</h2>
<div class="row" style="margin-top: 1rem;">
  <div class="card">
    <h3 class="card-title">Current Status</h3>
    <div class="small mb-2">Last update: <span id="statusUpdated">never</span></div>
    <table id="statusKv" class="table table-sm table-striped align-middle mb-0">
      <thead class="table-light">
        <tr>
          <th style="width: 220px;">Key</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody id="statusKvBody"></tbody>
    </table>
  </div>
</div>
<div class="row">
  <div class="card">
    <div>
      <h3>Live Rate (events/s)</h3>
      <div class="stat"><span id="rate">–</span></div>
      <div class="small">Computed using absolute timestamps (<code>ts</code>) over the selected time window.</div>
      <div class="controls" style="margin-top:.5rem">
        <label>Poll (s)
          <input type="number" id="pollSec" min="1" value="2">
        </label>
        <label>Window
          <select id="windowSel">
            <option value="300">5 min</option>
            <option value="1800" selected>30 min</option>
            <option value="3600">1 hour</option>
            <option value="7200">2 hours</option>
            <option value="21600">6 hours</option>
          </select>
        </label>
        <button id="reload" class="btn" style="padding:.3rem .8rem;">Reload</button>
      </div>
      <div class="chart-container">
        <canvas id="plot"></canvas>
      </div>
    </div>
  </div>
</div>
<div class="row" style="margin-top: 1rem;">
  <div class="card">
    <h3>Controls</h3>
    <div class="controls">
      <label>Threshold (0–4095)
        <input type="number" id="thresholdInput" min="0" max="4095" step="1" placeholder="e.g. 2048">
      </label>
      <button id="sendThreshold" class="btn">Send</button>
      <span id="thresholdStatus" class="small"></span>
    </div>
    <div class="small">Sends JSON to MQTT topic <code>control/{{ device_id }}/set</code>.</div>
  </div>
</div>
<div class="row" style="margin-top: 1rem;">
  <div class="card">
    <h3>Latest Samples</h3>
    <table>
      <thead>
        <tr>
          <th>ts</th>
          <th>muon_count</th>
          <th>adc_v</th>
          <th>temp_adc_v</th>
          <th>dt</th>
          <th>coincidence</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>
{% endblock %}
{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script>
      const deviceId = "{{ device_id }}";

      const elRate = document.getElementById('rate');
      const elPlot = document.getElementById('plot');
      const elBody = document.getElementById('tbody');
      const elPoll = document.getElementById('pollSec');
      const elWindow = document.getElementById('windowSel');
      const elReload = document.getElementById('reload');

      let timer = null;
      let inFlight = false;
      let backoffMs = 0; // grows on errors, reset on success

      // Initialize Chart.js line chart
      const rateChart = new Chart(elPlot.getContext('2d'), {
        type: 'line',
        data: {
          datasets: [{
            label: 'Rate (events/s)',
            data: [],
            borderColor: '#1f77b4',
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
          }]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'yyyy-MM-dd HH:mm:ss', unit: 'minute' },
              title: { display: true, text: 'Time (UTC)' }
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: 'Rate (events/s)' }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: { mode: 'index', intersect: false }
          }
        }
      });

      function computeRates(rows, windowSec) {
        // rows are typically newest-first from /api; normalize to time-ascending and drop bad rows
        const YEAR2000 = 946684800; // seconds since epoch
        const asc = [];
        for (const r of [...rows]) {
          if (!r || r.muon_count == null || !r.ts) continue;
          const tSec = new Date(r.ts).getTime() / 1000; // seconds
          if (!isFinite(tSec) || tSec < YEAR2000) continue;
          asc.push({ t: tSec, c: Number(r.muon_count) });
        }
        // sort ascending by time in case backend returns mixed order
        asc.sort((a,b) => a.t - b.t);
        if (asc.length < 2) return [];

        const rates = [];
        let j = 0;

        for (let i = 0; i < asc.length; i++) {
          const ti = asc[i].t;
          // maintain time window using timestamps
          while (j < i && (ti - asc[j].t) > windowSec) j++;
          if (j === i) continue; // need at least one interval in window

          const elapsed = ti - asc[j].t;
          if (!(elapsed > 0)) continue; // avoid div-by-zero or identical timestamps

          let dc = asc[i].c - asc[j].c;
          if (dc < 0) dc = 0; // guard counter wrap/rollover

          const r = dc > 0 ? dc / elapsed : 0;
          if (isFinite(r)) rates.push({ t: ti, r });
        }
        return rates;
      }

      // Replaces drawPlot
      function updateChart(rates) {
        // Set x-axis window to match selected time window
        if (rates.length) {
          const windowSec = Math.max(300, Number(elWindow.value) || 1800);
          const now = Date.now();
          rateChart.options.scales.x.min = now - windowSec * 1000;
          rateChart.options.scales.x.max = now;
        } else {
          rateChart.options.scales.x.min = undefined;
          rateChart.options.scales.x.max = undefined;
        }
        rateChart.data.datasets[0].data = rates.map(p => ({ x: p.t * 1000, y: p.r }));
        rateChart.update();
      }

      function renderTable(rows) {
        const latest = rows.slice(0, 50); // show newest 50
        elBody.innerHTML = latest.map(r => `
          <tr>
            <td>${r.ts ?? ''}</td>
            <td>${r.muon_count ?? ''}</td>
            <td>${r.adc_v ?? ''}</td>
            <td>${r.temp_adc_v ?? ''}</td>
            <td>${r.dt ?? ''}</td>
            <td>${r.coincidence ? 'true' : 'false'}</td>
          </tr>
        `).join('');
      }

      async function loadOnce() {
        if (inFlight) return;
        inFlight = true;
        const windowSec = Math.max(300, Number(elWindow.value) || 1800); // enforce ≥5 min

        // Heuristic: limit fetch size to keep CPU/mem bounded. Assume ≤5 Hz worst case.
        const estMaxRate = 5; // events/sec upper bound
        const limit = Math.min(5000, Math.max(500, Math.ceil(windowSec * estMaxRate)));

        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), 10000); // 10s timeout

        try {
          const res = await fetch(`/api/samples/${encodeURIComponent(deviceId)}?limit=${limit}&_ts=${Date.now()}`, { signal: controller.signal });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json(); // newest-first

          // Keep only samples within the selected window for table display
          const nowMs = Date.now();
          const sinceMs = nowMs - windowSec * 1000;
          const inWindow = data.filter(r => {
            if (!r.ts) return false;
            const tms = new Date(r.ts).getTime();
            return isFinite(tms) && tms >= sinceMs;
          });
          renderTable(inWindow.length ? inWindow : data.slice(0, 50)); // fallback if empty

          const rates = computeRates(data, windowSec);
          if (rates.length) {
            elRate.textContent = rates[rates.length - 1].r.toFixed(2);
          } else {
            elRate.textContent = '–';
          }
          updateChart(rates);

          // success -> reset backoff
          backoffMs = 0;
        } catch (e) {
          console.error('loadOnce error', e);
          // nudge UI to show stale
          elRate.textContent = '–';
          // increase backoff up to 30s and schedule a one-off retry
          backoffMs = Math.min(30000, (backoffMs || 2000) * 2);
          setTimeout(() => {
            // only retry if we are not already polling (avoid stampede)
            if (!inFlight) loadOnce().catch(() => {});
          }, backoffMs);
        } finally {
          clearTimeout(t);
          inFlight = false;
        }
      }

      function startPolling() {
        const sec = Math.max(1, Number(elPoll.value) || 2);
        if (timer) clearInterval(timer);
        timer = setInterval(() => {
          // if a previous load is still running, skip this tick
          if (!inFlight) loadOnce().catch(() => {});
        }, sec * 1000);
      }

      elReload.addEventListener('click', () => {
        loadOnce().catch(console.error);
      });

      // Kickoff
      loadOnce().catch(console.error);
      startPolling();
      elPoll.addEventListener('change', startPolling);

      // Refresh immediately when the selected time window changes
      elWindow.addEventListener('change', () => {
        loadOnce().catch(console.error);
      });

      // Pause polling when the tab is hidden to avoid browser throttling; resume when visible
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          if (timer) {
            clearInterval(timer);
            timer = null;
          }
        } else {
          // on return, do an immediate refresh and restart polling
          loadOnce().catch(() => {});
          startPolling();
        }
      });

      // Live status (current values) via WebSocket
      const statusKvBody = document.getElementById('statusKvBody');
      const elStatusUpdated = document.getElementById('statusUpdated');
      let currentStatus = null;

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }

      function renderStatusKV() {
        if (!currentStatus) return;
        const entries = Object.entries(currentStatus).filter(([k,_]) => !String(k).startsWith('_'));
        entries.sort(([a],[b]) => a.localeCompare(b));
        statusKvBody.innerHTML = entries.map(([k,v]) => {
          let val = v;
          if (typeof v === 'object' && v !== null) val = JSON.stringify(v);
          return `<tr><th scope="row">${escapeHtml(k)}</th><td><code>${escapeHtml(val)}</code></td></tr>`;
        }).join('');
      }
      try {
        const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
        const ws = new WebSocket(`${wsProto}://${location.host}/ws`);
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            const topic = msg.topic || '';
            if (topic === `status/${deviceId}`) {
              const payload = msg.payload;
              currentStatus = (payload && typeof payload === 'object') ? payload : { message: String(payload) };
              if (elStatusUpdated) elStatusUpdated.textContent = new Date().toISOString();
              renderStatusKV();
            }
          } catch {}
        };
      } catch {}

      // Periodic refresh (every 30 seconds) to re-render latest values
      setInterval(renderStatusKV, 30000);

      // Threshold control
      const elThr = document.getElementById('thresholdInput');
      const elThrBtn = document.getElementById('sendThreshold');
      const elThrStatus = document.getElementById('thresholdStatus');

      async function sendThreshold() {
        elThrStatus.textContent = '';
        const raw = elThr.value.trim();
        if (!raw) {
          elThrStatus.textContent = 'Enter a value';
          return;
        }
        const n = Number(raw);
        if (!Number.isInteger(n) || n < 0 || n > 4095) {
          elThrStatus.textContent = 'Must be integer 0–4095';
          return;
        }
        try {
          const res = await fetch(`/api/control/${encodeURIComponent(deviceId)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ threshold: n })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || data.ok === false) {
            elThrStatus.textContent = data.error || 'Failed to send';
          } else {
            elThrStatus.textContent = 'Sent';
          }
        } catch (e) {
          elThrStatus.textContent = 'Network error';
        }
      }

      elThrBtn.addEventListener('click', sendThreshold);
    </script>
{% endblock %}
